<project name="cumulus_ci" default="deployWithoutTest" basedir="." xmlns:sf="antlib:com.salesforce">

    <dirname property="cumulus_ci.basedir" file="${ant.file.cumulus_ci}"/>

    <include file="${cumulus_ci.basedir}/cumulusci.xml" />

    <taskdef 
         resource="net/sf/antcontrib/antlib.xml"
         classpath="${cumulus_ci.basedir}/lib/ant-contrib-1.0b2.jar" />

    <!-- If no propertyfile was passed in command line, attempt to load a build.properties if it exists -->
    <if>
        <and>
            <not>
                <isset property="sf:username" />
            </not>
            <available file="${basedir}/build.properties" />
        </and>
        <then>
            <loadproperties srcFile="${basedir}/build.properties"/>
        </then>
    </if>

    <!-- If there are environment variables set, consider them an override for org credentials -->
    <property environment="env" />

    <if>
      <isset property="env.SF_USERNAME" />
      <then>
        <var name="sf.username" value="${env.SF_USERNAME}" />
      </then>
    </if>
    <if>
      <isset property="env.SF_PASSWORD" />
      <then>
        <var name="sf.password" value="${env.SF_PASSWORD}" />
      </then>
    </if>
    <if>
      <isset property="env.SF_SERVERURL" />
      <then>
        <var name="sf.serverurl" value="${env.SF_SERVERURL}" />
      </then>
    </if>

    <!-- Load up cumulusci.properties file with package specific properties -->
    <loadproperties srcFile="${basedir}/cumulusci.properties"/>

    <!-- Set default values for properties not provided in cumulusci.properties -->
    <property name="cumulusci.package.name.managed" value="${cumulusci.package.name}" />
    <property name="cumulusci.package.installClass" value="" />
    <property name="cumulusci.package.uninstallClass" value="" />
    <property name="cumulusci.package.apiVersion" value="37.0" />
    <property name="cumulusci.maxPoll.test" value="400" />
    <property name="cumulusci.maxPoll.notest" value="200" />
    <property name="cumulusci.maxPoll.managed" value="400" />
    <property name="cumulusci.apexdoc.version" value="1.1.4" />
    <property name="cumulusci.apexdoc.scope" value="global;public;private;testmethod;webService" />
    <property name="cumulusci.apexdoc.branch" value="gh-pages" />

    <!-- urlencode the package name to handle special characters -->
    <urlencode name="cumulusci.package.name.encoded" value="${cumulusci.package.name}" />
    <urlencode name="cumulusci.package.name.managed.encoded" value="${cumulusci.package.name.managed}" />
    <var name="cumulusci.package.name" value="${cumulusci.package.name.encoded}" />
    <var name="cumulusci.package.name.managed" value="${cumulusci.package.name.managed.encoded}" />

    <!-- Allow TEST_JSON_OUTPUT environment variable to override cumulusci.test.jsonoutput -->
    <if>
      <isset property="env.TEST_JSON_OUTPUT" />
      <then>
        <var name="cumulusci.test.jsonoutput" value="${env.TEST_JSON_OUTPUT}" />
      </then>
      <else>
        <property name="cumulusci.test.jsonoutput" value="" />
      </else>
    </if>

    <!-- Allow APEX_TEST_NAME_MATCH environment variable to override cumulusci.test.namematch -->
    <if>
      <isset property="env.APEX_TEST_NAME_MATCH" />
      <then>
        <var name="cumulusci.test.namematch" value="${env.APEX_TEST_NAME_MATCH}" />
      </then>
      <else>
        <property name="cumulusci.test.namematch" value="%\_TEST" />
      </else>
    </if>
    
    <!-- Allow APEX_TEST_NAME_EXCLUDE environment variable to override cumulusci.test.nameexclude -->
    <if>
      <isset property="env.APEX_TEST_NAME_EXCLUDE" />
      <then>
        <var name="cumulusci.test.nameexclude" value="${env.APEX_TEST_NAME_EXCLUDE}" />
      </then>
      <else>
        <property name="cumulusci.test.nameexclude" value="" />
      </else>
    </if>

    <!-- Allow UNMANAGED_DESTROY_MODE environment variable to override cumulusci.unmanaged.destroy.mode -->
    <if>
      <isset property="env.UNMANAGED_DESTROY_MODE" />
      <then>
        <var name="cumulusci.unmanaged.destroy.mode" value="${env.UNMANAGED_DESTROY_MODE}" />
      </then>
      <else>
        <property name="cumulusci.unmanaged.destroy.mode" value="full" />
      </else>
    </if>

    <!-- Allow PURGE_ON_DELETE environment variable to override cumulusci.destroy.purgeondelete -->
    <if>
      <isset property="env.PURGE_ON_DELETE" />
      <then>
        <var name="cumulusci.destroy.purgeondelete" value="${env.PURGE_ON_DELETE}" />
      </then>
      <else>
        <property name="cumulusci.destroy.purgeondelete" value="true" />
      </else>
    </if>

    <!-- Setup a blank namespace prefix string.  Managed deployments need to override this property before calling deployUnpackagedPost -->
    <property name="cumulusci.namespace.prefix" value="" />
    
    <!-- Primary Build Targets -->

    <!-- deploy: Run a full deployment including running all tests.  Does not attempt to clean target org or ensure dependent package versions are correct -->
    <target name="deploy">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="deployWithoutTest" />
        <antcall target="runAllTests" />
        <!-- Changed to deploy then test due to suspicion that staging the deployment to run tests was causing a failure with every other build
          <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="src" testLevel="RunLocalTests" maxPoll="${cumulusci.maxPoll.test}" />
          -->
    </target>

    <!-- deployWithoutTest: Run a full deployment but don't run all tests.  This is useful if you already know tests will pass from previous runs and just want to deploy faster -->
    <target name="deployWithoutTest">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="preDeploy" />
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="src" maxPoll="${cumulusci.maxPoll.notest}" />
        <antcall target="postDeploy" />
    </target>

    <!-- deployUnpackagedPre: Deploy the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="deployUnpackagedPre">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" />
    </target>

    <!-- deployUnpackagedPost: Deploy the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="deployUnpackagedPost">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" />
    </target>

    <!-- deployManagedUnpackagedPre: Deploy the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package.  Use the managed namespace prefix -->
    <target name="deployManagedUnpackagedPre">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" nsprefix="${cumulusci.package.namespace}__" />
    </target>

    <!-- deployManagedUnpackagedPost: Deploy the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package.  Use the managed namespace prefix -->
    <target name="deployManagedUnpackagedPost">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" nsprefix="${cumulusci.package.namespace}__" />
    </target>

    <!-- zipUnpackagedBundles: Populates unpackaged/zipped with non-namespaced versions of all pre and post deployment bundles -->
    <target name="zipUnpackagedBundles">
        <echo>----------------------------------------------------------------------------</echo>
        <zipMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/zipped" />
        <zipMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/zipped" />
    </target>

    <!-- zipUnpackagedBundles: Populates unpackaged/zipped with namespaced versions of all pre and post deployment bundles -->
    <target name="zipManagedUnpackagedBundles">
        <echo>----------------------------------------------------------------------------</echo>
        <zipMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/namespaced_zipped" nsprefix="${cumulusci.package.namespace}__" />
        <zipMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/namespaced_zipped" nsprefix="${cumulusci.package.namespace}__" />
    </target>


    <!-- uninstallUnpackagedPre: Uninstall the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="uninstallUnpackagedPre">
        <if>
            <available file="${basedir}/unpackaged/pre/" type="dir" />
            <then>
                <for param="dir">
                    <path>
                        <dirset dir="${basedir}/unpackaged/pre/" includes="*" />
                    </path>
                    <sequential>
                        <echo>Uninstalling unpackaged bundle @{dir}</echo>
                        <delete dir="uninstall" />
                        <buildPackagedDestructiveChanges srcdir="@{dir}" dir="uninstall" package="${cumulusci.package.name}" />
                        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
                        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall" purgeOnDelete="${cumulusci.destroy.purgeondelete}" ignoreWarnings="true" maxPoll="${cumulusci.maxPoll.notest}" />
                        <delete dir="uninstall" />
                    </sequential>
                </for>
            </then>
            <else>
                <echo>No bundles found in unpackaged/pre</echo>
            </else>
        </if>
    </target>

    <!-- uninstallUnpackagedPost: Uninstall the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="uninstallUnpackagedPost">
        <if>
            <available file="${basedir}/unpackaged/post/" type="dir" />
            <then>
                <for param="dir">
                    <path>
                        <dirset dir="${basedir}/unpackaged/post/" includes="*" />
                    </path>
                    <sequential>
                        <echo>Deploying unpackaged bundle @{dir}</echo>
                        <echo>Uninstalling unpackaged bundle @{dir}</echo>
                        <delete dir="uninstall" />
                        <buildPackagedDestructiveChanges srcdir="@{dir}" dir="uninstall" package="${cumulusci.package.name}" />
                        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
                        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall" purgeOnDelete="${cumulusci.destroy.purgeondelete}" ignoreWarnings="true" maxPoll="${cumulusci.maxPoll.notest}" />
                        <delete dir="uninstall" />
                    </sequential>
                </for>
            </then>
            <else>
                <echo>No bundles found in unpackaged/post</echo>
            </else>
        </if>
    </target>

    <!-- deployCI: Does a full build including uninstalling previously deployed unpackaged code, updating managed package versions, and then deploying with all tests -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployCI">
        <echo>============================================================================</echo>
        <antcall target="bindOrg" />
        <antcall target="preDeployCI" />

        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Deploy the src directory -->
        <antcall target="deployWithoutTest" />
        
        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>
        
        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <!-- Run all tests -->
        <antcall target="runAllTests" />

        <!-- Uninstall unpackaged post bundles since they may reference code in the package -->
        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployCI" />
        <antcall target="releaseOrg" />
    </target>

    <!-- deployCIPackageOrg: Does a full build against the package org.  This differs from deployCI in that it uses destroyStaleMetadata instead of uninstall.
             There are a few assumptions.  We never downgrade a dependent managed package in the packaging org.  This removes the need to completely remove
             all metadata to allow a package downgrade.  In the package org, we can't delete all metadata once a production managed release is cut so this approach is required -->
    <target name="deployCIPackageOrg">
        <echo>============================================================================</echo>
        <antcall target="preDeployCIPackageOrg" />

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Update the package.xml to managed package mode, adding install and uninstall script classes -->
        <antcall target="updatePackageXmlManaged" />

        <!-- Attempt to destroy any stale metadata but continue even if this fails -->
        <trycatch>
            <try>
                <antcall target="destroyStaleMetadataManaged" />
            </try>
            <catch>
                <echo>First run of destroyStaleMetadataManaged failed.  Ignoring for now but it may cause build failures in other targets.</echo>
            </catch>
        </trycatch>

        <!-- Prepare the managed version of the src directory -->
        <antcall target="createManagedSrc" />

        <!-- Deploy src directory -->
        <antcall target="deployWithoutTest" />

        <!-- Revert the src directory -->
        <antcall target="revertManagedSrc" />

        <!-- Finally, delete any metadata from the org which is not in the repo -->
        <antcall target="destroyStaleMetadataManaged" />

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <!-- Run all tests -->
        <antcall target="runAllTestsManaged" />

        <antcall target="postDeployCIPackageOrg" />
    </target>

    <!-- Deploys the latest managed beta release to an org -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployManagedBeta">
        <echo>============================================================================</echo>
        <antcall target="preDeployManagedBeta" />

        <echo>BUILD_COMMIT = ${env.BUILD_COMMIT}</echo>
        <if>
            <and>
                <isset property="env.BUILD_COMMIT" />
                <not>
                    <equals arg1="env.BUILD_COMMIT" arg2="" />
                </not>
                <isset property="env.PACKAGE_VERSION" />
                <not>
                    <equals arg1="env.PACKAGE_VERSION" arg2="" />
                </not>
            </and>
            <then>
                <!-- If a BUILD_COMMIT and PACKAGE_VERSION are provided in the environment, use them -->
                <property name="managed_beta_tag" value="${env.BUILD_COMMIT}" />
                <property name="version.managed.beta" value="${env.PACKAGE_VERSION}" />
                <echo>Building with environment variables: BUILD_COMMIT=${managed_beta_tag}, PACKAGE_VERSION=${version.managed.beta}</echo>
            </then>
            <else>
                <!-- If no BUILD_COMMIT or PACKAGE_VERSION was provided in environment, call mrbelvedere to fetch latest released version -->
                <!-- Get the latest beta release tag name -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/beta/tag" dest="${basedir}/managed_beta_tag" />
                <loadfile property="managed_beta_tag" srcfile="${basedir}/managed_beta_tag" />
                <delete file="${basedir}/managed_beta_tag" />

                <!-- Get the latest beta release version number -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/beta" dest="${basedir}/version_beta" />
                <loadfile property="version.managed.beta" srcfile="${basedir}/version_beta" />
                <delete file="${basedir}/version_beta" />
            </else>
        </if>

        <!-- Fetch the version.properties file for the release from GitHub -->
        <if>
            <and>
                <isset property="env.GITHUB_USERNAME" />
                <not>
                    <equals arg1="env.GITHUB_USERNAME" arg2="" />
                </not>
            </and>
            <then>
                <!-- Fetch the version.properties file for the release from GitHub -->
                <exec executable="curl">
                    <arg line="-u '${env.GITHUB_USERNAME}:${env.GITHUB_PASSWORD}' --header 'Accept: application/vnd.github.v3.raw' https://api.github.com/repos/${env.GITHUB_ORG_NAME}/${env.GITHUB_REPO_NAME}/contents/version.properties?ref=${managed_beta_tag} -o ${basedir}/version.properties.beta"/>
                </exec>
            </then>
            <else>
                <!-- Fetch the version.properties file for the release from GitHub -->
                <get src="${cumulusci.github.url.raw}/${managed_beta_tag}/version.properties" dest="${basedir}/version.properties.beta" />
            </else>
        </if>

        <!-- Since we want to use the versions required by the tag rather than the currently checked out code, unset all version properties and load the version.properties.beta file -->
        <var file="${basedir}/version.properties.beta" />
        <delete file="${basedir}/version.properties.beta" />

        <!-- Update all required packages and uninstall current beta -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployManagedUnpackagedPre" />

        <!-- Install the beta packages -->
        <var name="version.managed" value="${version.managed.beta}" />
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployManagedUnpackagedPost" />

        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployManagedBeta" />
    </target>

    <!-- Deploys the latest production managed release to an org -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployManaged">
        <echo>============================================================================</echo>
        <antcall target="preDeployManaged" />

        <echo>BUILD_COMMIT = ${env.BUILD_COMMIT}</echo>
        <if>
            <and>
                <isset property="env.BUILD_COMMIT" />
                <not>
                    <equals arg1="env.BUILD_COMMIT" arg2="" />
                </not>
                <isset property="env.PACKAGE_VERSION" />
                <not>
                    <equals arg1="env.PACKAGE_VERSION" arg2="" />
                </not>
            </and>
            <then>
                <!-- If a BUILD_COMMIT and PACKAGE_VERSION are provided in the environment, use them -->
                <property name="managed_prod_tag" value="${env.BUILD_COMMIT}" />
                <property name="version.managed.prod" value="${env.PACKAGE_VERSION}" />
                <echo>Building with environment variables: BUILD_COMMIT=${managed_prod_tag}, PACKAGE_VERSION=${version.npsp.managed}</echo>
            </then>
            <else>
                <!-- If no BUILD_COMMIT or PACKAGE_VERSION was provided in environment, call mrbelvedere to fetch latest released version -->
                <!-- Get the latest production release tag name -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/tag" dest="${basedir}/managed_prod_tag" />
                <loadfile property="managed_prod_tag" srcfile="${basedir}/managed_prod_tag" />
                <delete file="${basedir}/managed_prod_tag" />

                <!-- Get the latest production release version number -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version" dest="${basedir}/version_prod" />
                <loadfile property="version.managed.prod" srcfile="${basedir}/version_prod" />
                <delete file="${basedir}/version_prod" />
            </else>
        </if>

        <!-- Fetch the version.properties file for the release from GitHub -->
        <get src="${cumulusci.github.url.raw}/${managed_prod_tag}/version.properties" dest="${basedir}/version.properties.prod" />

        <!-- Since we want to use the versions required by the tag rather than the currently checked out code, unset all version properties and load the version.properties.prod file -->
        <var file="${basedir}/version.properties.prod" />
        <delete file="${basedir}/version.properties.prod" />
        <var name="version.managed" value="${version.managed.prod}" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployManagedUnpackagedPre" />

        <!-- Run updateRequiredPackages to install the correct versions of required packages and the main package -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed for builds -->
        <antcall target="deployManagedUnpackagedPost" />

        <!-- Uninstall the unpackaged post bundles so they don't cause dependency issues in the next build -->
        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployManaged" />
    </target>

    <!-- Utility Build Targets -->

    <target name="bindOrg">
        <!-- binds an org to a 'build transaction' using the org credentials as identifier for the org.

        You need an org to build and test a feature branch. The total build process consists of multiple steps and
        multiple force.com migration tool calls against the org some of them changing the state of the org. If
        another build would start using that org during his build process, both builds would fail since the org
        status would become indeterminate. If you 'bind the org' to your build at the start of your build process,
        that would stop the other build to use 'your' org. You have to release the org though after you have used it.

        This only is needed when you do not have exclusive access to the org. So only on CI systems in general.
         -->
        <exec executable="cumulusci" failonerror="true">
            <arg value="ci" />
            <arg value="bind_org" />
            <arg value="--fail" />
            <arg value="true" /> <!-- TODO make it wait -->
        </exec>
    </target>

    <target name="releaseOrg">
        <!-- releases the org by updating the commit context -->
        <!-- TODO: call the correct command through the CLI -->
        <exec executable="cumulusci" failonerror="true">
            <arg value="dev" />
            <arg value="update_package_xml" />
            <arg value="--directory" />
            <arg value="@{srcDir}" />
            <arg value="--output" />
            <arg value="@{srcDir}/package.xml" />
        </exec>
    </target>

    <target name="destroyStaleMetadata">
        <echo>----------------------------------------------------------------------------</echo>
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />

        <!-- Fetch all metadata in the  package from target org -->
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name}" />

        <!-- Build a destructiveChanges.xml pacckage to delete metadata in org but not in repo -->
        <buildDestroyStaleMetadata srcdir="uninstallsrc" commdir="src" dir="uninstall" />

        <!-- deploy the destructiveChanges.xml package -->
        <echo>Deleting metdata with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall" purgeOnDelete="${cumulusci.destroy.purgeondelete}" maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <target name="destroyStaleMetadataManaged">
        <echo>----------------------------------------------------------------------------</echo>
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />

        <!-- Fetch all metadata in the  package from target org -->
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name.managed}" />

        <!-- Build a destructiveChanges.xml pacckage to delete metadata in org but not in repo -->
        <buildDestroyStaleMetadata srcdir="uninstallsrc" commdir="src" dir="uninstall" />

        <!-- deploy the destructiveChanges.xml package -->
        <echo>Deleting metdata with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall" purgeOnDelete="${cumulusci.destroy.purgeondelete}" maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <!-- uninstall: Removes all metadata from the package -->
    <target name="uninstall">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="preUninstall" />
        <antcall target="uninstallUnpackagedPost" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name}" />
        <buildPackagedDestructiveChanges srcdir="uninstallsrc" dir="uninstall" package="${cumulusci.package.name}" />
        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall" purgeOnDelete="${cumulusci.destroy.purgeondelete}" maxPoll="${cumulusci.maxPoll.notest}" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <antcall target="uninstallUnpackagedPre" />
        <antcall target="postUninstall" />
    </target>

    <!-- uninstall: Removes all non-standard unpackaged metadata from the org -->
    <target name="uninstallUnpackaged">
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <retrieveUnpackaged dir="uninstallsrc" />
        <deleteWhitelistedMetadata dir="uninstallsrc/unpackaged" />
        <buildUnpackagedDestructiveChanges srcdir="uninstallsrc" dir="uninstall" />
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall/standard" maxPoll="${cumulusci.maxPoll.notest}" />
        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="uninstall/unpackaged" purgeOnDelete="${cumulusci.destroy.purgeondelete}" maxPoll="${cumulusci.maxPoll.notest}" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <!-- Get and echo currently installed vs required versions of all required packages -->
    <macrodef name="getPackageVersions" description="Gets the version for all installed packages">
        <sequential>
            <delete dir="${basedir}/installedPackages"/>
            <mkdir dir="${basedir}/installedPackages"/>
    
            <sf:bulkRetrieve
                username="${sf.username}"
                password="${sf.password}"
                metadataType="InstalledPackage"
                retrieveTarget="${basedir}/installedPackages"/>
    
            <echo>Required Package Versions:</echo>
            <echo>-------------------------------</echo>
    
            <for list="${required.packages}" delimiter="," param="packageNamespace">
                <sequential>
                    <if>
                        <equals arg1="@{packageNamespace}" arg2="managed" />
                        <then>
                            <getPackageVersion namespace="${cumulusci.package.namespace}" refresh="false" />
                            <propertycopy property="packageVersionInstalled" from="InstalledPackage.${cumulusci.package.namespace}.versionNumber" />
                            <echo>${cumulusci.package.namespace}: ${packageVersionInstalled} (${version.@{packageNamespace}} required)</echo>
                        </then>
                        <else>
                            <getPackageVersion namespace="@{packageNamespace}" refresh="false" />
                            <echo>@{packageNamespace}: ${InstalledPackage.@{packageNamespace}.versionNumber} (${version.@{packageNamespace}} required)</echo>
                        </else>
                    </if>
                </sequential>
            </for>
    
            <delete dir="${basedir}/installedPackages"/>
        </sequential>
    </macrodef>

    <!-- updateDependendentPackages: Ensures all dependent packages are the correct version -->
    <target name="updateRequiredPackages">
        <echo>----------------------------------------------------------------------------</echo>
        <getPackageVersions />
        <antcall target="preUpdateRequiredPackages" />
        <for list="${required.packages}" delimiter="," param="packageNamespace">
            <sequential>
                <if>
                    <equals arg1="@{packageNamespace}" arg2="managed" />
                    <then>
                        <updatePackageVersion namespace="${cumulusci.package.namespace}" version="${version.@{packageNamespace}}" />
                    </then>
                    <else>
                        <echo>Deploying pre bundles for @{packageNamespace}</echo>
                        <if>
                            <available file="${basedir}/unpackaged/@{packageNamespace}/pre" type="dir" />
                            <then>
                                <deployMetadataBundles dir="${basedir}/unpackaged/@{packageNamespace}/pre" stagedir="${basedir}/unpackaged_stage" />
                            </then>
                            <else>
                                <echo>No pre bundles found for @{packageNamespace} at ${basedir}/unpackaged/@{packageNamespace}/pre</echo>
                            </else>
                        </if>
                        <updatePackageVersion namespace="@{packageNamespace}" version="${version.@{packageNamespace}}" />
                        <echo>Deploying post bundles for @{packageNamespace}</echo>
                        <if>
                            <available file="${basedir}/unpackaged/@{packageNamespace}/post" type="dir" />
                            <then>
                                <deployMetadataBundles dir="${basedir}/unpackaged/@{packageNamespace}/post" stagedir="${basedir}/unpackaged_stage" />
                            </then>
                            <else>
                                <echo>No post bundles found for @{packageNamespace} at ${basedir}/unpackaged/@{packageNamespace}/post</echo>
                            </else>
                        </if>
                    </else>
                </if>
            </sequential>
        </for>
        <antcall target="postUpdateRequiredPackages" />
    </target>

    <!-- Developer focused build targets -->

    <!-- deployDevOrg: Does a full build including uninstalling previously deployed packaged code, updating managed package versions, and then deploying without running tests.  Use this target to quickly refresh a dev org. -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean development environment. -->
    <target name="deployDevOrg">
        <echo>============================================================================</echo>
        <antcall target="preDeployCI" />

        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Deploy the src directory -->
        <antcall target="deployWithoutTest" />
        
        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>
        
        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <antcall target="postDeployCI" />
    </target>

    <!-- deployUnmanagedEE: Does a full build including uninstalling previously deployed packaged code, updating managed package versions, and then deploying without running tests.  Use this target to quickly deploy the unmanaged code into a fresh DE org. -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean development environment. -->
    <target name="deployUnmanagedEE">
        <echo>============================================================================</echo>
        <antcall target="preDeployCI" />

        <!-- Override the purgeOnDelete=true default since we can't do that in EE orgs -->
        <var name="cumulus.destroy.purgeondelete" value="false" />

        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Prepare the unmanaged EE version of the src directory -->
        <antcall target="createUnmanagedEESrc" />

        <!-- Deploy src directory -->
        <antcall target="deployWithoutTest" />

        <!-- Revert the src directory -->
        <antcall target="revertUnmanagedEESrc" />
        
        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>
        
        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <antcall target="postDeployCI" />
    </target>


    <!-- retrieveUnpackaged: Retrieves all unpackaged metadata from target org into the unpackaged directory -->
    <target name="retrieveUnpackaged">
        <retrieveUnpackaged dir="org_unpackaged" />
    </target>

    <!-- retrievePackaged: Retrieves all metadata from the package in the target org into the packaged directory -->
    <target name="retrievePackaged">
        <retrievePackaged dir="packaged" package="${cumulusci.package.name}" />
    </target>
    
    <!-- retrievePackagedToSrc: Retrieves all metadata from the package in the target org into the src directory --> 
    <target name="retrievePackagedToSrc"> 
        <retrievePackaged dir="src" package="${cumulusci.package.name}" mkdir="false" /> 
    </target>

    <!-- createUnmanagedPackage: Does an empty deployment into an unmanaged package to create it if it does not exist -->
    <target name="createUnmanagedPackage">
        <if>
            <isset property="cumulusci.package.name" />
            <then>
                <delete dir="${basedir}/create_package" />
                <mkdir dir="${basedir}/create_package" />
                <buildPackageXml package="${cumulusci.package.name}" version="${cumulusci.package.apiVersion}" srcDir="create_package" />
                <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="create_package" maxPoll="${cumulusci.maxPoll.notest}" />
                <delete dir="${basedir}/create_package" />
            </then>
        </if>
    </target>

    <!-- runAllTests: Runs all unmanaged tests -->
    <target name="runAllTests">
        <echo>----------------------------------------------------------------------------</echo>
        <if>
            <equals arg1="${env.TEST_MODE}" arg2="parallel" />
            <then>
                <exec executable="python" failonerror="true">
                  <env key="SF_USERNAME" value="${sf.username}" />
                  <env key="SF_PASSWORD" value="${sf.password}" />
                  <env key="SF_SERVERURL" value="${sf.serverurl}" />
                  <env key="TEST_JSON_OUTPUT" value="${cumulusci.test.jsonoutput}" />
                  <env key="APEX_TEST_NAME_MATCH" value="${cumulusci.test.namematch}" />
                  <env key="APEX_TEST_NAME_EXCLUDE" value="${cumulusci.test.nameexclude}" />
                  <arg value="${cumulus_ci.basedir}/../ci/run_apex_tests.py" />
                </exec>
            </then>
            <else>
                <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="${cumulus_ci.basedir}/empty" testLevel="RunLocalTests" maxPoll="${cumulusci.maxPoll.test}" />
            </else>
        </if>
    </target>

    <!-- runAllTestsManaged: Runs all managed tests from package's namespace -->
    <target name="runAllTestsManaged">
        <echo>----------------------------------------------------------------------------</echo>
        <if>
            <equals arg1="${env.TEST_MODE}" arg2="parallel" />
            <then>
                <exec executable="python" failonerror="true">
                  <env key="SF_USERNAME" value="${sf.username}" />
                  <env key="SF_PASSWORD" value="${sf.password}" />
                  <env key="SF_SERVERURL" value="${sf.serverurl}" />
                  <env key="TEST_JSON_OUTPUT" value="${cumulusci.test.jsonoutput}" />
                  <env key="APEX_TEST_NAME_MATCH" value="${cumulusci.test.namematch}" />
                  <env key="APEX_TEST_NAME_EXCLUDE" value="${cumulusci.test.nameexclude}" />
                  <env key="NAMESPACE" value="${cumulusci.package.namespace}" />
                  <arg value="${cumulus_ci.basedir}/../ci/run_apex_tests.py" />
                </exec>
            </then>
            <else>
                <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="${cumulus_ci.basedir}/empty" testLevel="RunAllTestsInOrg" maxPoll="${cumulusci.maxPoll.test}" />
            </else>
        </if>
    </target>

    <!-- updatePackageXml: Builds a new package.xml based upon the metadata in the src directory -->
    <target name="updatePackageXml">
        <buildPackageXml package="${cumulusci.package.name}" version="${cumulusci.package.apiVersion}" />
    </target>

    <target name="updatePackageXmlManaged">
        <buildPackageXml package="${cumulusci.package.name.managed}" version="${cumulusci.package.apiVersion}" installClass="${cumulusci.package.installClass}" uninstallClass="${cumulusci.package.uninstallClass}" type="managed" />
    </target>

    <target name="updateMetaXml">
        <for list="${required.packages}" delimiter="," param="packageNamespace">
            <sequential>
                <if>
                    <not><equals arg1="@{packageNamespace}" arg2="managed" /></not>
                    <then>
                        <updateMetaXml dir="${basedir}/src" namespace="@{packageNamespace}" version="${version.@{packageNamespace}}" />
                    </then>
                </if>
            </sequential>
        </for>
        <updateMetaXmlApi dir="${basedir}/src" apiVersion="${cumulusci.package.apiVersion}" />
    </target>

    <!-- Update the Admin.profile to grant all FLS permissions -->
    <target name="deployUpdatedAdminProfile">
        <echo>Retrieving Admin.profile</echo>
        <retrieveAdminProfile dir="admin_profile" />

        <echo>Granting read/edit FLS on all fields in Admin.profile</echo>
        <updateAdminProfileGrantFLS dir="admin_profile" />

        <antcall target="preDeployUpdatedAdminProfile" />

        <echo>Deploying updated Admin.profile</echo>
        <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="admin_profile" maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="admin_profile" />
    </target>

    <!-- Run stripManagedToken against src for managed deployment -->
    <target name="createManagedSrc">
        <delete dir="src.orig" />
        <copy todir="src.orig" preservelastmodified="true">
          <fileset dir="src" />
        </copy>
        <stripManagedToken dir="src" />
    </target>

    <!-- Revert the src directory from createManagedSrc -->
    <target name="revertManagedSrc">
        <copy todir="src" preservelastmodified="true" overwrite="true">
          <fileset dir="src.orig" />
        </copy>
        <delete dir="src.orig" />
    </target>

    <!-- Run prepareSrcForUnmanagedEE against src for unmanaged deployment to EE orgs -->
    <target name="createUnmanagedEESrc">
        <delete dir="src.orig" />
        <copy todir="src.orig" preservelastmodified="true">
          <fileset dir="src" />
        </copy>
        <prepareSrcForUnmanagedEE dir="src" />
    </target>

    <!-- Revert the src directory from createUnmanagedEESrc -->
    <target name="revertUnmanagedEESrc">
        <copy todir="src" preservelastmodified="true" overwrite="true">
          <fileset dir="src.orig" />
        </copy>
        <delete dir="src.orig" />
    </target>

    <!-- Generate developer documentation of src using ApexDoc -->
    <target name="generateApexDoc">

        <!-- Set up properties needed to clone the src repo for doc generation -->
        <if>
            <isset property="env.APEXDOC_TAG" />
            <then>
                <property name="apexdoc.src" value="../${cumulusci.package.name}ApexDocSrc" />
                <property name="apexdoc.github.linkbase" value="${cumulusci.apexdoc.linkbase}/blob/${env.APEXDOC_TAG}/src/classes/" />
                <property name="apexdoc.src.ref" value="tags/${env.APEXDOC_TAG}" />
            </then>
            <else>
                <if>
                    <isset property="env.APEXDOC_BRANCH" />
                    <then>
                        <property name="apexdoc.src" value="../${cumulusci.package.name}ApexDocSrc" />
                        <property name="apexdoc.github.linkbase" value="${cumulusci.apexdoc.linkbase}/blob/${env.APEXDOC_BRANCH}/src/classes/" />
                        <property name="apexdoc.src.ref" value="${env.APEXDOC_BRANCH}" />
                    </then>
                    <else>
                        <fail>ERROR: You must provide an APEXDOC_TAG or APEXDOC_BRANCH environment variable</fail>
                    </else>
                </if>
            </else>
        </if>

        <!-- Clone the repo and check out to the correct ref as the source for ApexDoc generation -->
        <delete dir="${apexdoc.src}" />
        <exec executable="git" failonerror="true">
            <arg line="clone ${cumulusci.apexdoc.repo} ${apexdoc.src}" />
        </exec>
        <exec executable="git" failonerror="true" dir="${apexdoc.src}">
            <arg line="checkout ${apexdoc.src.ref}" />
        </exec>

        <!-- Clone the repo, this copy will hold the generated docs -->
        <delete dir="../${cumulusci.package.name}ApexDoc" />
        <exec executable="git" failonerror="true">
            <arg line="clone ${cumulusci.apexdoc.repo} ../${cumulusci.package.name}ApexDoc" />
        </exec>
        <exec executable="git" failonerror="true" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="checkout ${cumulusci.apexdoc.branch}" />
        </exec>
            
        <!-- Download apexdoc.jar -->
        <delete dir="${cumulus_ci.basedir}/../ci/doc" />
        <mkdir dir="${cumulus_ci.basedir}/../ci/doc" />
        <get src="https://github.com/SalesforceFoundation/ApexDoc/releases/download/${cumulusci.apexdoc.version}/apexdoc.jar" dest="${cumulus_ci.basedir}/../ci/doc/apexdoc.jar" />

        <!-- Run ApexDoc -->
        <echo>
            java -jar ${cumulus_ci.basedir}/../ci/doc/apexdoc.jar
                -s ${apexdoc.src}/src/classes
                -t ../${cumulusci.package.name}ApexDoc
                -h '${cumulusci.apexdoc.content.homepage}'
                -a '${cumulusci.apexdoc.content.banner}'
                -p '${cumulusci.apexdoc.scope}'
                -g '${apexdoc.github.linkbase}
        </echo>
        <java jar="${cumulus_ci.basedir}/../ci/doc/apexdoc.jar" failonerror="true" fork="true">
            <arg line="-s ${apexdoc.src}/src/classes" />
            <arg line="-t ../${cumulusci.package.name}ApexDoc" />
            <arg line="-h '${cumulusci.apexdoc.content.homepage}'" />
            <arg line="-a '${cumulusci.apexdoc.content.banner}'" />
            <arg line="-p '${cumulusci.apexdoc.scope}'" />
            <arg line="-g '${apexdoc.github.linkbase}'" />
            <!--
            -->
        </java>

        <!-- Move files from ApexDocumentation to the root of the target repo -->
        <!-- commented out to keep the subdirectory
        <move todir="../${cumulusci.package.name}ApexDoc">
            <fileset dir="../${cumulusci.package.name}ApexDoc/ApexDocumentation">
              <include name="**/*" />
            </fileset>
        </move>
        <delete dir="../${cumulusci.package.name}ApexDoc/ApexDocumentation" />
        -->

        <exec executable="git" failonerror="true" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="add --all" />
        </exec>
        <exec executable="git" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="commit -m 'Generated docs for ${apexdoc.src.ref}'" />
        </exec>
        <exec executable="git" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="push" />
        </exec>

        <!-- Delete created files and directories -->
        <delete dir="${cumulus_ci.basedir}/../ci/doc" />
        <delete dir="../${cumulusci.package.name}ApexDoc" />
        <delete dir="${apexdoc.src}" />

    </target>

    <!-- Override hook targets: These targets are empty in the core file but exist for allowing projects to hook in their own custom logic without overriding the core targets -->

    <!-- Before uninstall -->
    <target name="preUninstall">
        <echo>Nothing to do for preUninstall</echo>
    </target>
    <!-- After uninstall. -->
    <target name="postUninstall">
        <echo>Nothing to do for postUninstall</echo>
    </target>

    <!-- Before updateRequiredPackages.  Can be used to uninstall packages in a downgrade scenario if building an extension package -->
    <target name="preUpdateRequiredPackages">
        <echo>Nothing to do for preUpdateRequiredPackages</echo>
    </target>
    <!-- After updateRequiredPackages. -->
    <target name="postUpdateRequiredPackages">
        <echo>Nothing to do for postUpdateRequiredPackages</echo>
    </target>

    <!-- Before deploy of src directory -->
    <target name="preDeploy">
        <echo>Nothing to do for preDeploy</echo>
    </target>
    <!-- After deploy of src directory -->
    <target name="postDeploy">
        <echo>Nothing to do for postDeploy</echo>
    </target>

    <!-- Before deployCI -->
    <target name="preDeployCI">
        <echo>Nothing to do for preDeployCI</echo>
    </target>
    <!-- After deployCI -->
    <target name="postDeployCI">
        <echo>Nothing to do for postDeployCI</echo>
    </target>

    <!-- Before deployCIPackageOrg -->
    <target name="preDeployCIPackageOrg">
        <echo>Nothing to do for preDeployCIPackageOrg</echo>
    </target>
    <!-- After deployCIPackageOrg -->
    <target name="postDeployCIPackageOrg">
        <echo>Nothing to do for postDeployCIPackageOrg</echo>
    </target>

    <!-- Before deployManaged -->
    <target name="preDeployManaged">
        <echo>Nothing to do for preDeployManaged</echo>
    </target>
    <!-- After deployManaged -->
    <target name="postDeployManaged">
        <echo>Nothing to do for postDeployManaged</echo>
    </target>

    <!-- Before deployManagedBeta -->
    <target name="preDeployManagedBeta">
        <echo>Nothing to do for preDeployManagedBeta</echo>
    </target>
    <!-- After deployManagedBeta -->
    <target name="postDeployManagedBeta">
        <echo>Nothing to do for postDeployManagedBeta</echo>
    </target>
    <!-- Before deployment is run in deployUpdatedAdminProfile -->
    <target name="preDeployUpdatedAdminProfile">
        <echo>Nothing to do for preDeployUpdatedAdminProfile</echo>
    </target>

</project>
