<project name="cumulus_ci" default="deployWithoutTest" basedir="." xmlns:sf="antlib:com.salesforce">

    <dirname property="cumulus_ci.basedir" file="${ant.file.cumulus_ci}"/>

    <include file="${cumulus_ci.basedir}/cumulusci.xml" />

    <taskdef
         resource="net/sf/antcontrib/antlib.xml"
         classpath="${cumulus_ci.basedir}/lib/ant-contrib-1.0b2.jar" />

    <!-- If no propertyfile was passed in command line, attempt to load a build.properties if it exists -->
    <if>
        <and>
            <not>
                <isset property="sf:username" />
            </not>
            <available file="${basedir}/build.properties" />
        </and>
        <then>
            <loadproperties srcFile="${basedir}/build.properties"/>
        </then>
    </if>

    <!-- If there are environment variables set, consider them an override for org credentials -->
    <property environment="env" />

    <if>
      <isset property="env.SF_USERNAME" />
      <then>
        <var name="sf.username" value="${env.SF_USERNAME}" />
      </then>
    </if>
    <if>
      <isset property="env.SF_PASSWORD" />
      <then>
        <var name="sf.password" value="${env.SF_PASSWORD}" />
      </then>
    </if>
    <if>
      <isset property="env.SF_SERVERURL" />
      <then>
        <var name="sf.serverurl" value="${env.SF_SERVERURL}" />
      </then>
    </if>
   
    <if>
      <isset property="env.SF_SESSIONID" />
      <then>
        <var name="sf.sessionId" value="${env.SF_SESSIONID}" />
        <var name="sf.username" value="" />
        <var name="sf.password" value="" />
      </then>
      <else>
        <var name="sf.sessionId" value="" />
      </else>
    </if>
    
    <!-- Load up cumulusci.properties file with package specific properties -->
    <loadproperties srcFile="${basedir}/cumulusci.properties"/>

    <!-- Set default values for properties not provided in cumulusci.properties -->
    <property name="cumulusci.package.name.managed" value="${cumulusci.package.name}" />
    <property name="cumulusci.package.installClass" value="" />
    <property name="cumulusci.package.uninstallClass" value="" />
    <property name="cumulusci.package.apiVersion" value="31.0" />
    <property name="cumulusci.maxPoll.test" value="400" />
    <property name="cumulusci.maxPoll.notest" value="200" />
    <property name="cumulusci.maxPoll.managed" value="400" />
    <property name="cumulusci.apexdoc.version" value="1.1.4" />
    <property name="cumulusci.apexdoc.scope" value="global;public;private;testmethod;webService" />
    <property name="cumulusci.apexdoc.branch" value="gh-pages" />

    <!-- urlencode the package name to handle special characters -->
    <urlencode name="cumulusci.package.name.encoded" value="${cumulusci.package.name}" />
    <urlencode name="cumulusci.package.name.managed.encoded" value="${cumulusci.package.name.managed}" />
    <var name="cumulusci.package.name" value="${cumulusci.package.name.encoded}" />
    <var name="cumulusci.package.name.managed" value="${cumulusci.package.name.managed.encoded}" />

    <!-- Allow TEST_JSON_OUTPUT environment variable to override cumulusci.test.jsonoutput -->
    <if>
      <isset property="env.TEST_JSON_OUTPUT" />
      <then>
        <var name="cumulusci.test.jsonoutput" value="${env.TEST_JSON_OUTPUT}" />
      </then>
      <else>
        <property name="cumulusci.test.jsonoutput" value="" />
      </else>
    </if>

    <!-- Allow APEX_TEST_NAME_MATCH environment variable to override cumulusci.test.namematch -->
    <if>
      <isset property="env.APEX_TEST_NAME_MATCH" />
      <then>
        <var name="cumulusci.test.namematch" value="${env.APEX_TEST_NAME_MATCH}" />
      </then>
      <else>
        <property name="cumulusci.test.namematch" value="%\_TEST" />
      </else>
    </if>

    <!-- Allow APEX_TEST_NAME_EXCLUDE environment variable to override cumulusci.test.nameexclude -->
    <if>
      <isset property="env.APEX_TEST_NAME_EXCLUDE" />
      <then>
        <var name="cumulusci.test.nameexclude" value="${env.APEX_TEST_NAME_EXCLUDE}" />
      </then>
      <else>
        <property name="cumulusci.test.nameexclude" value="" />
      </else>
    </if>

    <!-- Allow UNMANAGED_DESTROY_MODE environment variable to override cumulusci.unmanaged.destroy.mode -->
    <if>
      <isset property="env.UNMANAGED_DESTROY_MODE" />
      <then>
        <var name="cumulusci.unmanaged.destroy.mode" value="${env.UNMANAGED_DESTROY_MODE}" />
      </then>
      <else>
        <property name="cumulusci.unmanaged.destroy.mode" value="full" />
      </else>
    </if>

    <!-- Allow PURGE_ON_DELETE environment variable to override cumulusci.destroy.purgeondelete -->
    <if>
      <isset property="env.PURGE_ON_DELETE" />
      <then>
        <var name="cumulusci.destroy.purgeondelete" value="${env.PURGE_ON_DELETE}" />
      </then>
      <else>
        <property name="cumulusci.destroy.purgeondelete" value="true" />
      </else>
    </if>

    <!-- Setup a blank namespace prefix string.  Managed deployments need to override this property before calling deployUnpackagedPost -->
    <property name="cumulusci.namespace.prefix" value="" />

    <!-- Primary Build Targets -->

    <!-- deploy: Run a full deployment including running all tests.  Does not attempt to clean target org or ensure dependent package versions are correct -->
    <target name="deploy">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="deployWithoutTest" />
        <antcall target="runAllTests" />
        <!-- Changed to deploy then test due to suspicion that staging the deployment to run tests was causing a failure with every other build
          <sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" deployRoot="src" testLevel="RunLocalTests" maxPoll="${cumulusci.maxPoll.test}" />
          -->
    </target>

    <!-- deployWithoutTest: Run a full deployment but don't run all tests.  This is useful if you already know tests will pass from previous runs and just want to deploy faster -->
    <target name="deployWithoutTest">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="preDeploy" />
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="src"
          maxPoll="${cumulusci.maxPoll.notest}" />
        <antcall target="postDeploy" />
    </target>

    <!-- deployUnpackagedPre: Deploy the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="deployUnpackagedPre">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" />
    </target>

    <!-- deployUnpackagedPost: Deploy the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="deployUnpackagedPost">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" />
    </target>

    <!-- deployManagedUnpackagedPre: Deploy the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package.  Use the managed namespace prefix -->
    <target name="deployManagedUnpackagedPre">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" nsprefix="${cumulusci.package.namespace}__" />
    </target>

    <!-- deployManagedUnpackagedPost: Deploy the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package.  Use the managed namespace prefix -->
    <target name="deployManagedUnpackagedPost">
        <echo>----------------------------------------------------------------------------</echo>
        <deployMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" nsprefix="${cumulusci.package.namespace}__" />
    </target>

    <!-- zipUnpackagedBundles: Populates unpackaged/zipped with non-namespaced versions of all pre and post deployment bundles -->
    <target name="zipUnpackagedBundles">
        <echo>----------------------------------------------------------------------------</echo>
        <zipMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/zipped" />
        <zipMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/zipped" />
    </target>

    <!-- zipUnpackagedBundles: Populates unpackaged/zipped with namespaced versions of all pre and post deployment bundles -->
    <target name="zipManagedUnpackagedBundles">
        <echo>----------------------------------------------------------------------------</echo>
        <zipMetadataBundles dir="${basedir}/unpackaged/pre" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/namespaced_zipped" nsprefix="${cumulusci.package.namespace}__" />
        <zipMetadataBundles dir="${basedir}/unpackaged/post" stagedir="${basedir}/unpackaged_stage" zipdir="unpackaged/namespaced_zipped" nsprefix="${cumulusci.package.namespace}__" />
    </target>


    <!-- uninstallUnpackagedPre: Uninstall the unpackaged/pre subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="uninstallUnpackagedPre">
        <if>
            <available file="${basedir}/unpackaged/pre/" type="dir" />
            <then>
                <for param="dir">
                    <path>
                        <dirset dir="${basedir}/unpackaged/pre/" includes="*" />
                    </path>
                    <sequential>
                        <echo>Uninstalling unpackaged bundle @{dir}</echo>
                        <delete dir="uninstall" />
                        <buildPackagedDestructiveChanges srcdir="@{dir}" dir="uninstall" package="${cumulusci.package.name}" />
                        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
                        <sf:deploy
                          username="${sf.username}"
                          password="${sf.password}"
                          serverurl="${sf.serverurl}"
                          apiVersion="${cumulusci.package.apiVersion}"
                          sessionId="${sf.sessionId}"
                          deployRoot="uninstall"
                          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
                          ignoreWarnings="true"
                          maxPoll="${cumulusci.maxPoll.notest}" />
                        <delete dir="uninstall" />
                    </sequential>
                </for>
            </then>
            <else>
                <echo>No bundles found in unpackaged/pre</echo>
            </else>
        </if>
    </target>

    <!-- uninstallUnpackagedPost: Uninstall the unpackaged/post subdirectories containing metadata used in builds but not included in the managed package -->
    <target name="uninstallUnpackagedPost">
        <if>
            <available file="${basedir}/unpackaged/post/" type="dir" />
            <then>
                <for param="dir">
                    <path>
                        <dirset dir="${basedir}/unpackaged/post/" includes="*" />
                    </path>
                    <sequential>
                        <echo>Deploying unpackaged bundle @{dir}</echo>
                        <echo>Uninstalling unpackaged bundle @{dir}</echo>
                        <delete dir="uninstall" />
                        <buildPackagedDestructiveChanges srcdir="@{dir}" dir="uninstall" package="${cumulusci.package.name}" />
                        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
                        <sf:deploy username="${sf.username}" 
                          password="${sf.password}"
                          serverurl="${sf.serverurl}"
                          apiVersion="${cumulusci.package.apiVersion}"
                          sessionId="${sf.sessionId}"
                          deployRoot="uninstall"
                          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
                          ignoreWarnings="true"
                          maxPoll="${cumulusci.maxPoll.notest}" />
                        <delete dir="uninstall" />
                    </sequential>
                </for>
            </then>
            <else>
                <echo>No bundles found in unpackaged/post</echo>
            </else>
        </if>
    </target>

    <!-- deployCI: Does a full build including uninstalling previously deployed unpackaged code, updating managed package versions, and then deploying with all tests -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployCI">
        <echo>============================================================================</echo>
        <antcall target="preDeployCI" />

        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Deploy the src directory -->
        <antcall target="deployWithoutTest" />

        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <!-- Run all tests -->
        <antcall target="runAllTests" />

        <!-- Uninstall unpackaged post bundles since they may reference code in the package -->
        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployCI" />
    </target>

    <!-- deployCIPackageOrg: Does a full build against the package org.  This differs from deployCI in that it uses destroyStaleMetadata instead of uninstall.
             There are a few assumptions.  We never downgrade a dependent managed package in the packaging org.  This removes the need to completely remove
             all metadata to allow a package downgrade.  In the package org, we can't delete all metadata once a production managed release is cut so this approach is required -->
    <target name="deployCIPackageOrg">
        <echo>============================================================================</echo>
        <antcall target="preDeployCIPackageOrg" />

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Update the package.xml to managed package mode, adding install and uninstall script classes -->
        <antcall target="updatePackageXmlManaged" />

        <!-- Attempt to destroy any stale metadata but continue even if this fails -->
        <trycatch>
            <try>
                <antcall target="destroyStaleMetadataManaged" />
            </try>
            <catch>
                <echo>First run of destroyStaleMetadataManaged failed.  Ignoring for now but it may cause build failures in other targets.</echo>
            </catch>
        </trycatch>

        <!-- Prepare the managed version of the src directory -->
        <antcall target="createManagedSrc" />

        <!-- Deploy src directory -->
        <antcall target="deployWithoutTest" />

        <!-- Revert the src directory -->
        <antcall target="revertManagedSrc" />

        <!-- Finally, delete any metadata from the org which is not in the repo -->
        <antcall target="destroyStaleMetadataManaged" />

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <!-- Run all tests -->
        <antcall target="runAllTestsManaged" />

        <antcall target="postDeployCIPackageOrg" />
    </target>

    <!-- Deploys the latest managed beta release to an org -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployManagedBeta">
        <echo>============================================================================</echo>
        <antcall target="preDeployManagedBeta" />

        <echo>BUILD_COMMIT = ${env.BUILD_COMMIT}</echo>
        <if>
            <and>
                <isset property="env.BUILD_COMMIT" />
                <not>
                    <equals arg1="env.BUILD_COMMIT" arg2="" />
                </not>
                <isset property="env.PACKAGE_VERSION" />
                <not>
                    <equals arg1="env.PACKAGE_VERSION" arg2="" />
                </not>
            </and>
            <then>
                <!-- If a BUILD_COMMIT and PACKAGE_VERSION are provided in the environment, use them -->
                <property name="managed_beta_tag" value="${env.BUILD_COMMIT}" />
                <property name="version.managed.beta" value="${env.PACKAGE_VERSION}" />
                <echo>Building with environment variables: BUILD_COMMIT=${managed_beta_tag}, PACKAGE_VERSION=${version.managed.beta}</echo>
            </then>
            <else>
                <!-- If no BUILD_COMMIT or PACKAGE_VERSION was provided in environment, call mrbelvedere to fetch latest released version -->
                <!-- Get the latest beta release tag name -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/beta/tag" dest="${basedir}/managed_beta_tag" />
                <loadfile property="managed_beta_tag" srcfile="${basedir}/managed_beta_tag" />
                <delete file="${basedir}/managed_beta_tag" />

                <!-- Get the latest beta release version number -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/beta" dest="${basedir}/version_beta" />
                <loadfile property="version.managed.beta" srcfile="${basedir}/version_beta" />
                <delete file="${basedir}/version_beta" />
            </else>
        </if>

        <!-- Fetch the version.properties file for the release from GitHub -->
        <if>
            <and>
                <isset property="env.GITHUB_USERNAME" />
                <not>
                    <equals arg1="env.GITHUB_USERNAME" arg2="" />
                </not>
            </and>
            <then>
                <!-- Fetch the version.properties file for the release from GitHub -->
                <exec executable="curl">
                    <arg line="-u '${env.GITHUB_USERNAME}:${env.GITHUB_PASSWORD}' --header 'Accept: application/vnd.github.v3.raw' https://api.github.com/repos/${env.GITHUB_ORG_NAME}/${env.GITHUB_REPO_NAME}/contents/version.properties?ref=${managed_beta_tag} -o ${basedir}/version.properties.beta"/>
                </exec>
            </then>
            <else>
                <!-- Fetch the version.properties file for the release from GitHub -->
                <get src="${cumulusci.github.url.raw}/${managed_beta_tag}/version.properties" dest="${basedir}/version.properties.beta" />
            </else>
        </if>

        <!-- Since we want to use the versions required by the tag rather than the currently checked out code, unset all version properties and load the version.properties.beta file -->
        <var file="${basedir}/version.properties.beta" />
        <delete file="${basedir}/version.properties.beta" />

        <!-- Update all required packages and uninstall current beta -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployManagedUnpackagedPre" />

        <!-- Install the beta packages -->
        <var name="version.managed" value="${version.managed.beta}" />
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployManagedUnpackagedPost" />

        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployManagedBeta" />
    </target>

    <!-- Deploys the latest production managed release to an org -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean build test. -->
    <target name="deployManaged">
        <echo>============================================================================</echo>
        <antcall target="preDeployManaged" />

        <echo>BUILD_COMMIT = ${env.BUILD_COMMIT}</echo>
        <if>
            <and>
                <isset property="env.BUILD_COMMIT" />
                <not>
                    <equals arg1="env.BUILD_COMMIT" arg2="" />
                </not>
                <isset property="env.PACKAGE_VERSION" />
                <not>
                    <equals arg1="env.PACKAGE_VERSION" arg2="" />
                </not>
            </and>
            <then>
                <!-- If a BUILD_COMMIT and PACKAGE_VERSION are provided in the environment, use them -->
                <property name="managed_prod_tag" value="${env.BUILD_COMMIT}" />
                <property name="version.managed.prod" value="${env.PACKAGE_VERSION}" />
                <echo>Building with environment variables: BUILD_COMMIT=${managed_prod_tag}, PACKAGE_VERSION=${version.npsp.managed}</echo>
            </then>
            <else>
                <!-- If no BUILD_COMMIT or PACKAGE_VERSION was provided in environment, call mrbelvedere to fetch latest released version -->
                <!-- Get the latest production release tag name -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version/tag" dest="${basedir}/managed_prod_tag" />
                <loadfile property="managed_prod_tag" srcfile="${basedir}/managed_prod_tag" />
                <delete file="${basedir}/managed_prod_tag" />

                <!-- Get the latest production release version number -->
                <get src="${cumulusci.mrbelvedere.url}/mrbelvedere/repo/${cumulusci.mrbelvedere.repo.owner}/${cumulusci.mrbelvedere.repo.name}/version" dest="${basedir}/version_prod" />
                <loadfile property="version.managed.prod" srcfile="${basedir}/version_prod" />
                <delete file="${basedir}/version_prod" />
            </else>
        </if>

        <!-- Fetch the version.properties file for the release from GitHub -->
        <get src="${cumulusci.github.url.raw}/${managed_prod_tag}/version.properties" dest="${basedir}/version.properties.prod" />

        <!-- Since we want to use the versions required by the tag rather than the currently checked out code, unset all version properties and load the version.properties.prod file -->
        <var file="${basedir}/version.properties.prod" />
        <delete file="${basedir}/version.properties.prod" />
        <var name="version.managed" value="${version.managed.prod}" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployManagedUnpackagedPre" />

        <!-- Run updateRequiredPackages to install the correct versions of required packages and the main package -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed for builds -->
        <antcall target="deployManagedUnpackagedPost" />

        <!-- Uninstall the unpackaged post bundles so they don't cause dependency issues in the next build -->
        <antcall target="uninstallUnpackagedPost" />

        <antcall target="postDeployManaged" />
    </target>

    <!-- Utility Build Targets -->

    <target name="destroyStaleMetadata">
        <echo>----------------------------------------------------------------------------</echo>
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />

        <!-- Fetch all metadata in the  package from target org -->
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name}" />

        <!-- Build a destructiveChanges.xml pacckage to delete metadata in org but not in repo -->
        <buildDestroyStaleMetadata srcdir="uninstallsrc" commdir="src" dir="uninstall" />

        <!-- deploy the destructiveChanges.xml package -->
        <echo>Deleting metdata with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="uninstall"
          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
          maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <target name="destroyStaleMetadataManaged">
        <echo>----------------------------------------------------------------------------</echo>
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />

        <!-- Fetch all metadata in the  package from target org -->
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name.managed}" />

        <!-- Build a destructiveChanges.xml pacckage to delete metadata in org but not in repo -->
        <buildDestroyStaleMetadata srcdir="uninstallsrc" commdir="src" dir="uninstall" />

        <!-- deploy the destructiveChanges.xml package -->
        <echo>Deleting metdata with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="uninstall"
          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
          maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <!-- uninstall: Removes all metadata from the package -->
    <target name="uninstall">
        <echo>----------------------------------------------------------------------------</echo>
        <antcall target="preUninstall" />
        <antcall target="uninstallUnpackagedPost" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <retrievePackaged dir="uninstallsrc" package="${cumulusci.package.name}" />
        <buildPackagedDestructiveChanges srcdir="uninstallsrc" dir="uninstall" package="${cumulusci.package.name}" />
        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="uninstall"
          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
          maxPoll="${cumulusci.maxPoll.notest}" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <antcall target="uninstallUnpackagedPre" />
        <antcall target="postUninstall" />
    </target>

    <!-- uninstall: Removes all non-standard unpackaged metadata from the org -->
    <target name="uninstallUnpackaged">
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
        <retrieveUnpackaged dir="uninstallsrc" />
        <deleteWhitelistedMetadata dir="uninstallsrc/unpackaged" />
        <buildUnpackagedDestructiveChanges srcdir="uninstallsrc" dir="uninstall" />
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="uninstall/standard"
          maxPoll="${cumulusci.maxPoll.notest}" />
        <echo>Uninstalling with purgeOnDelete=${cumulusci.destroy.purgeondelete}</echo>
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="uninstall/unpackaged"
          purgeOnDelete="${cumulusci.destroy.purgeondelete}"
          maxPoll="${cumulusci.maxPoll.notest}" />
        <delete dir="uninstallsrc" />
        <delete dir="uninstall" />
    </target>

    <!-- Get and echo currently installed vs required versions of all required packages -->
    <macrodef name="getPackageVersions" description="Gets the version for all installed packages">
        <sequential>
            <delete dir="${basedir}/installedPackages"/>
            <mkdir dir="${basedir}/installedPackages"/>

            <sf:bulkRetrieve
                username="${sf.username}"
                password="${sf.password}"
                serverurl="${sf.serverurl}"
                apiVersion="${cumulusci.package.apiVersion}"
                sessionId="${sf.sessionId}"
                metadataType="InstalledPackage"
                retrieveTarget="${basedir}/installedPackages"/>

            <echo>Required Package Versions:</echo>
            <echo>-------------------------------</echo>

            <for list="${required.packages}" delimiter="," param="packageNamespace">
                <sequential>
                    <if>
                        <equals arg1="@{packageNamespace}" arg2="managed" />
                        <then>
                            <getPackageVersion namespace="${cumulusci.package.namespace}" refresh="false" />
                            <propertycopy property="packageVersionInstalled" from="InstalledPackage.${cumulusci.package.namespace}.versionNumber" />
                            <echo>${cumulusci.package.namespace}: ${packageVersionInstalled} (${version.@{packageNamespace}} required)</echo>
                        </then>
                        <else>
                            <getPackageVersion namespace="@{packageNamespace}" refresh="false" />
                            <echo>@{packageNamespace}: ${InstalledPackage.@{packageNamespace}.versionNumber} (${version.@{packageNamespace}} required)</echo>
                        </else>
                    </if>
                </sequential>
            </for>

            <delete dir="${basedir}/installedPackages"/>
        </sequential>
    </macrodef>

    <!-- updateDependendentPackages: Ensures all dependent packages are the correct version -->
    <target name="updateRequiredPackages">
        <echo>----------------------------------------------------------------------------</echo>
        <getPackageVersions />
        <antcall target="preUpdateRequiredPackages" />
        <for list="${required.packages}" delimiter="," param="packageNamespace">
            <sequential>
                <if>
                    <equals arg1="@{packageNamespace}" arg2="managed" />
                    <then>
                        <updatePackageVersion namespace="${cumulusci.package.namespace}" version="${version.@{packageNamespace}}" />
                    </then>
                    <else>
                        <echo>Deploying pre bundles for @{packageNamespace}</echo>
                        <if>
                            <available file="${basedir}/unpackaged/@{packageNamespace}/pre" type="dir" />
                            <then>
                                <deployMetadataBundles dir="${basedir}/unpackaged/@{packageNamespace}/pre" stagedir="${basedir}/unpackaged_stage" />
                            </then>
                            <else>
                                <echo>No pre bundles found for @{packageNamespace} at ${basedir}/unpackaged/@{packageNamespace}/pre</echo>
                            </else>
                        </if>
                        <updatePackageVersion namespace="@{packageNamespace}" version="${version.@{packageNamespace}}" />
                        <echo>Deploying post bundles for @{packageNamespace}</echo>
                        <if>
                            <available file="${basedir}/unpackaged/@{packageNamespace}/post" type="dir" />
                            <then>
                                <deployMetadataBundles dir="${basedir}/unpackaged/@{packageNamespace}/post" stagedir="${basedir}/unpackaged_stage" />
                            </then>
                            <else>
                                <echo>No post bundles found for @{packageNamespace} at ${basedir}/unpackaged/@{packageNamespace}/post</echo>
                            </else>
                        </if>
                    </else>
                </if>
            </sequential>
        </for>
        <antcall target="postUpdateRequiredPackages" />
    </target>

    <!-- Developer focused build targets -->

    <!-- deployDevOrg: Does a full build including uninstalling previously deployed packaged code, updating managed package versions, and then deploying without running tests.  Use this target to quickly refresh a dev org. -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean development environment. -->
    <target name="deployDevOrg">
        <echo>============================================================================</echo>
        <antcall target="preDeployCI" />

        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Deploy the src directory -->
        <antcall target="deployWithoutTest" />

        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <antcall target="postDeployCI" />
    </target>

    <!-- deployUnmanagedEE: Does a full build including uninstalling previously deployed packaged code, updating managed package versions, and then deploying without running tests.  Use this target to quickly deploy the unmanaged code into a fresh DE org. -->
    <!-- !!!WARNING!!!: DO NOT run this against a real production org as it will delete everything.  It is designed to clear the target org to ensure a clean development environment. -->
    <target name="deployUnmanagedEE">
        <echo>============================================================================</echo>
        <antcall target="preDeployCI" />

        <!-- Override the purgeOnDelete=true default since we can't do that in EE orgs -->
        <var name="cumulus.destroy.purgeondelete" value="false" />

        <echo>${sf.username}</echo>
        <!-- Create the unmanaged package if it doesn't already exist -->
        <antcall target="createUnmanagedPackage" inheritRefs="true" />

        <!-- Uninstall all unpackaged code from the target org.  We have to do this first so we can uninstall and reinstall any managed packages not at the right version -->
        <if>
            <equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" />
            <then>
                <antcall target="uninstall" />
            </then>
            <else>
                <!-- Attempt to destroy any stale metadata but continue even if this fails -->
                <trycatch>
                    <try>
                        <antcall target="destroyStaleMetadata" />
                    </try>
                    <catch>
                        <echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
                    </catch>
                </trycatch>
            </else>
        </if>

        <!-- Update any managed packages which are not at the right version -->
        <antcall target="updateRequiredPackages" />

        <!-- Deploy any unpackaged metadata bundles needed before the deployment -->
        <antcall target="deployUnpackagedPre" />

        <!-- Prepare the unmanaged EE version of the src directory -->
        <antcall target="createUnmanagedEESrc" />

        <!-- Deploy src directory -->
        <antcall target="deployWithoutTest" />

        <!-- Revert the src directory -->
        <antcall target="revertUnmanagedEESrc" />

        <if>
            <not><equals arg1="${cumulusci.unmanaged.destroy.mode}" arg2="full" /></not>
            <then>
                <!-- Finally, delete any metadata from the org which is not in the repo -->
                <antcall target="destroyStaleMetadata" />
            </then>
        </if>

        <!-- Deploy any unpackaged metadata bundles needed after the deployment -->
        <antcall target="deployUnpackagedPost" />

        <antcall target="postDeployCI" />
    </target>


    <!-- retrieveUnpackaged: Retrieves all unpackaged metadata from target org into the unpackaged directory -->
    <target name="retrieveUnpackaged">
        <retrieveUnpackaged dir="org_unpackaged" />
    </target>

    <!-- retrievePackaged: Retrieves all metadata from the package in the target org into the packaged directory -->
    <target name="retrievePackaged">
        <retrievePackaged dir="packaged" package="${cumulusci.package.name}" />
    </target>

    <!-- retrievePackagedToSrc: Retrieves all metadata from the package in the target org into the src directory -->
    <target name="retrievePackagedToSrc">
        <retrievePackaged dir="src" package="${cumulusci.package.name}" mkdir="false" />
    </target>

    <!-- createUnmanagedPackage: Does an empty deployment into an unmanaged package to create it if it does not exist -->
    <target name="createUnmanagedPackage">
        <if>
            <isset property="cumulusci.package.name" />
            <then>
                <delete dir="${basedir}/create_package" />
                <mkdir dir="${basedir}/create_package" />
                <buildPackageXml package="${cumulusci.package.name}" version="${cumulusci.package.apiVersion}" srcDir="create_package" />
                <sf:deploy username="${sf.username}"
                  password="${sf.password}"
                  serverurl="${sf.serverurl}"
                  apiVersion="${cumulusci.package.apiVersion}"
                  sessionId="${sf.sessionId}"
                  deployRoot="create_package"
                  maxPoll="${cumulusci.maxPoll.notest}" />
                <delete dir="${basedir}/create_package" />
            </then>
        </if>
    </target>

    <!-- runAllTests: Runs all unmanaged tests -->
    <target name="runAllTests">
        <echo>----------------------------------------------------------------------------</echo>
        <if>
            <equals arg1="${env.TEST_MODE}" arg2="parallel" />
            <then>
                <exec executable="python" failonerror="true">
                  <env key="SF_USERNAME" value="${sf.username}" />
                  <env key="SF_PASSWORD" value="${sf.password}" />
                  <env key="SF_SERVERURL" value="${sf.serverurl}" />
                  <env key="TEST_JSON_OUTPUT" value="${cumulusci.test.jsonoutput}" />
                  <env key="APEX_TEST_NAME_MATCH" value="${cumulusci.test.namematch}" />
                  <env key="APEX_TEST_NAME_EXCLUDE" value="${cumulusci.test.nameexclude}" />
                  <arg value="${cumulus_ci.basedir}/../ci/run_apex_tests.py" />
                </exec>
            </then>
            <else>
                <sf:deploy
                  username="${sf.username}"
                  password="${sf.password}"
                  serverurl="${sf.serverurl}"
                  apiVersion="${cumulusci.package.apiVersion}"
                  sessionId="${sf.sessionId}"
                  deployRoot="${cumulus_ci.basedir}/empty"
                  testLevel="RunLocalTests"
                  maxPoll="${cumulusci.maxPoll.test}" />
            </else>
        </if>
    </target>

    <!-- runAllTestsManaged: Runs all managed tests from package's namespace -->
    <target name="runAllTestsManaged">
        <echo>----------------------------------------------------------------------------</echo>
        <if>
            <equals arg1="${env.TEST_MODE}" arg2="parallel" />
            <then>
                <exec executable="python" failonerror="true">
                  <env key="SF_USERNAME" value="${sf.username}" />
                  <env key="SF_PASSWORD" value="${sf.password}" />
                  <env key="SF_SERVERURL" value="${sf.serverurl}" />
                  <env key="TEST_JSON_OUTPUT" value="${cumulusci.test.jsonoutput}" />
                  <env key="APEX_TEST_NAME_MATCH" value="${cumulusci.test.namematch}" />
                  <env key="APEX_TEST_NAME_EXCLUDE" value="${cumulusci.test.nameexclude}" />
                  <env key="NAMESPACE" value="${cumulusci.package.namespace}" />
                  <arg value="${cumulus_ci.basedir}/../ci/run_apex_tests.py" />
                </exec>
            </then>
            <else>
                <sf:deploy
                  username="${sf.username}"
                  password="${sf.password}"
                  serverurl="${sf.serverurl}"
                  apiVersion="${cumulusci.package.apiVersion}"
                  sessionId="${sf.sessionId}"
                  deployRoot="${cumulus_ci.basedir}/empty"
                  testLevel="RunAllTestsInOrg"
                  maxPoll="${cumulusci.maxPoll.test}" />
            </else>
        </if>
    </target>

    <!-- updatePackageXml: Builds a new package.xml based upon the metadata in the src directory -->
    <target name="updatePackageXml">
        <buildPackageXml package="${cumulusci.package.name}" version="${cumulusci.package.apiVersion}" />
    </target>

    <target name="updatePackageXmlManaged">
        <buildPackageXml package="${cumulusci.package.name.managed}" version="${cumulusci.package.apiVersion}" installClass="${cumulusci.package.installClass}" uninstallClass="${cumulusci.package.uninstallClass}" type="managed" />
    </target>

    <target name="updateMetaXml">
        <for list="${required.packages}" delimiter="," param="packageNamespace">
            <sequential>
                <if>
                    <not><equals arg1="@{packageNamespace}" arg2="managed" /></not>
                    <then>
                        <updateMetaXml dir="${basedir}/src" namespace="@{packageNamespace}" version="${version.@{packageNamespace}}" />
                    </then>
                </if>
            </sequential>
        </for>
        <updateMetaXmlApi dir="${basedir}/src" apiVersion="${cumulusci.package.apiVersion}" />
    </target>

    <!-- Update the Admin.profile to grant all FLS permissions -->
    <target name="deployUpdatedAdminProfile">
        <echo>Retrieving Admin.profile</echo>
        <retrieveAdminProfile dir="admin_profile" />

        <echo>Granting read/edit FLS on all fields in Admin.profile</echo>
        <updateAdminProfileGrantFLS dir="admin_profile" />

        <antcall target="preDeployUpdatedAdminProfile" />

        <echo>Deploying updated Admin.profile</echo>
        <sf:deploy
          username="${sf.username}"
          password="${sf.password}"
          serverurl="${sf.serverurl}"
          apiVersion="${cumulusci.package.apiVersion}"
          sessionId="${sf.sessionId}"
          deployRoot="admin_profile"
          maxPoll="${cumulusci.maxPoll.notest}" />

        <delete dir="admin_profile" />
    </target>

    <!-- Run stripManagedToken against src for managed deployment -->
    <target name="createManagedSrc">
        <delete dir="src.orig" />
        <copy todir="src.orig" preservelastmodified="true">
          <fileset dir="src" />
        </copy>
        <stripManagedToken dir="src" />
    </target>

    <!-- Revert the src directory from createManagedSrc -->
    <target name="revertManagedSrc">
        <copy todir="src" preservelastmodified="true" overwrite="true">
          <fileset dir="src.orig" />
        </copy>
        <delete dir="src.orig" />
    </target>

    <!-- Run prepareSrcForUnmanagedEE against src for unmanaged deployment to EE orgs -->
    <target name="createUnmanagedEESrc">
        <delete dir="src.orig" />
        <copy todir="src.orig" preservelastmodified="true">
          <fileset dir="src" />
        </copy>
        <prepareSrcForUnmanagedEE dir="src" />
    </target>

    <!-- Revert the src directory from createUnmanagedEESrc -->
    <target name="revertUnmanagedEESrc">
        <copy todir="src" preservelastmodified="true" overwrite="true">
          <fileset dir="src.orig" />
        </copy>
        <delete dir="src.orig" />
    </target>

    <!-- Generate developer documentation of src using ApexDoc -->
    <target name="generateApexDoc">

        <!-- Set up properties needed to clone the src repo for doc generation -->
        <if>
            <isset property="env.APEXDOC_TAG" />
            <then>
                <property name="apexdoc.src" value="../${cumulusci.package.name}ApexDocSrc" />
                <property name="apexdoc.github.linkbase" value="${cumulusci.apexdoc.linkbase}/blob/${env.APEXDOC_TAG}/src/classes/" />
                <property name="apexdoc.src.ref" value="tags/${env.APEXDOC_TAG}" />
            </then>
            <else>
                <if>
                    <isset property="env.APEXDOC_BRANCH" />
                    <then>
                        <property name="apexdoc.src" value="../${cumulusci.package.name}ApexDocSrc" />
                        <property name="apexdoc.github.linkbase" value="${cumulusci.apexdoc.linkbase}/blob/${env.APEXDOC_BRANCH}/src/classes/" />
                        <property name="apexdoc.src.ref" value="${env.APEXDOC_BRANCH}" />
                    </then>
                    <else>
                        <fail>ERROR: You must provide an APEXDOC_TAG or APEXDOC_BRANCH environment variable</fail>
                    </else>
                </if>
            </else>
        </if>

        <!-- Clone the repo and check out to the correct ref as the source for ApexDoc generation -->
        <delete dir="${apexdoc.src}" />
        <exec executable="git" failonerror="true">
            <arg line="clone ${cumulusci.apexdoc.repo} ${apexdoc.src}" />
        </exec>
        <exec executable="git" failonerror="true" dir="${apexdoc.src}">
            <arg line="checkout ${apexdoc.src.ref}" />
        </exec>

        <!-- Clone the repo, this copy will hold the generated docs -->
        <delete dir="../${cumulusci.package.name}ApexDoc" />
        <exec executable="git" failonerror="true">
            <arg line="clone ${cumulusci.apexdoc.repo} ../${cumulusci.package.name}ApexDoc" />
        </exec>
        <exec executable="git" failonerror="true" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="checkout ${cumulusci.apexdoc.branch}" />
        </exec>

        <!-- Download apexdoc.jar -->
        <delete dir="${cumulus_ci.basedir}/../ci/doc" />
        <mkdir dir="${cumulus_ci.basedir}/../ci/doc" />
        <get src="https://github.com/SalesforceFoundation/ApexDoc/releases/download/${cumulusci.apexdoc.version}/apexdoc.jar" dest="${cumulus_ci.basedir}/../ci/doc/apexdoc.jar" />

        <!-- Run ApexDoc -->
        <echo>
            java -jar ${cumulus_ci.basedir}/../ci/doc/apexdoc.jar
                -s ${apexdoc.src}/src/classes
                -t ../${cumulusci.package.name}ApexDoc
                -h '${cumulusci.apexdoc.content.homepage}'
                -a '${cumulusci.apexdoc.content.banner}'
                -p '${cumulusci.apexdoc.scope}'
                -g '${apexdoc.github.linkbase}
        </echo>
        <java jar="${cumulus_ci.basedir}/../ci/doc/apexdoc.jar" failonerror="true" fork="true">
            <arg line="-s ${apexdoc.src}/src/classes" />
            <arg line="-t ../${cumulusci.package.name}ApexDoc" />
            <arg line="-h '${cumulusci.apexdoc.content.homepage}'" />
            <arg line="-a '${cumulusci.apexdoc.content.banner}'" />
            <arg line="-p '${cumulusci.apexdoc.scope}'" />
            <arg line="-g '${apexdoc.github.linkbase}'" />
            <!--
            -->
        </java>

        <!-- Move files from ApexDocumentation to the root of the target repo -->
        <!-- commented out to keep the subdirectory
        <move todir="../${cumulusci.package.name}ApexDoc">
            <fileset dir="../${cumulusci.package.name}ApexDoc/ApexDocumentation">
              <include name="**/*" />
            </fileset>
        </move>
        <delete dir="../${cumulusci.package.name}ApexDoc/ApexDocumentation" />
        -->

        <exec executable="git" failonerror="true" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="add --all" />
        </exec>
        <exec executable="git" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="commit -m 'Generated docs for ${apexdoc.src.ref}'" />
        </exec>
        <exec executable="git" dir="../${cumulusci.package.name}ApexDoc">
            <arg line="push" />
        </exec>

        <!-- Delete created files and directories -->
        <delete dir="${cumulus_ci.basedir}/../ci/doc" />
        <delete dir="../${cumulusci.package.name}ApexDoc" />
        <delete dir="${apexdoc.src}" />

    </target>

    <!-- Override hook targets: These targets are empty in the core file but exist for allowing projects to hook in their own custom logic without overriding the core targets -->

    <!-- Before uninstall -->
    <target name="preUninstall">
        <echo>Nothing to do for preUninstall</echo>
    </target>
    <!-- After uninstall. -->
    <target name="postUninstall">
        <echo>Nothing to do for postUninstall</echo>
    </target>

    <!-- Before updateRequiredPackages.  Can be used to uninstall packages in a downgrade scenario if building an extension package -->
    <target name="preUpdateRequiredPackages">
        <echo>Nothing to do for preUpdateRequiredPackages</echo>
    </target>
    <!-- After updateRequiredPackages. -->
    <target name="postUpdateRequiredPackages">
        <echo>Nothing to do for postUpdateRequiredPackages</echo>
    </target>

    <!-- Before deploy of src directory -->
    <target name="preDeploy">
        <echo>Nothing to do for preDeploy</echo>
    </target>
    <!-- After deploy of src directory -->
    <target name="postDeploy">
        <echo>Nothing to do for postDeploy</echo>
    </target>

    <!-- Before deployCI -->
    <target name="preDeployCI">
        <echo>Nothing to do for preDeployCI</echo>
    </target>
    <!-- After deployCI -->
    <target name="postDeployCI">
        <echo>Nothing to do for postDeployCI</echo>
    </target>

    <!-- Before deployCIPackageOrg -->
    <target name="preDeployCIPackageOrg">
        <echo>Nothing to do for preDeployCIPackageOrg</echo>
    </target>
    <!-- After deployCIPackageOrg -->
    <target name="postDeployCIPackageOrg">
        <echo>Nothing to do for postDeployCIPackageOrg</echo>
    </target>

    <!-- Before deployManaged -->
    <target name="preDeployManaged">
        <echo>Nothing to do for preDeployManaged</echo>
    </target>
    <!-- After deployManaged -->
    <target name="postDeployManaged">
        <echo>Nothing to do for postDeployManaged</echo>
    </target>

    <!-- Before deployManagedBeta -->
    <target name="preDeployManagedBeta">
        <echo>Nothing to do for preDeployManagedBeta</echo>
    </target>
    <!-- After deployManagedBeta -->
    <target name="postDeployManagedBeta">
        <echo>Nothing to do for postDeployManagedBeta</echo>
    </target>
    <!-- Before deployment is run in deployUpdatedAdminProfile -->
    <target name="preDeployUpdatedAdminProfile">
        <echo>Nothing to do for preDeployUpdatedAdminProfile</echo>
    </target>

</project>
